#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
#include <unordered_set>

using namespace std;

const std::unordered_set<std::string> cppKeywords = {
    // C++ Keywords
    "alignas", "alignof", "and", "and_eq", "asm", "atomic_cancel", "atomic_commit",
    "atomic_noexcept", "auto", "bitand", "bitor", "bool", "break", "case", "catch",
    "char", "char8_t", "char16_t", "char32_t", "class", "compl", "concept", "const",
    "consteval", "constexpr", "constinit", "const_cast", "continue", "co_await",
    "co_return", "co_yield", "decltype", "default", "delete", "do", "double", "dynamic_cast",
    "else", "enum", "explicit", "export", "extern", "false", "float", "for", "friend",
    "goto", "if", "import", "inline", "int", "long", "module", "mutable", "namespace",
    "new", "noexcept", "not", "not_eq", "nullptr", "operator", "or", "or_eq", "private",
    "protected", "public", "reflexpr", "register", "reinterpret_cast", "requires", "return",
    "short", "signed", "sizeof", "static", "static_assert", "static_cast", "struct", "switch",
    "synchronized", "template", "this", "thread_local", "throw", "true", "try", "typedef",
    "typeid", "typename", "union", "unsigned", "using", "virtual", "void", "volatile",
    "wchar_t", "while", "xor", "xor_eq", "include",

    // Standard Library Identifiers
    "std", "cin", "cout", "cerr", "clog", "endl", "flush", "setw", "setprecision",
    "ifstream", "ofstream", "fstream", "istringstream", "ostringstream", "stringstream",
    "vector", "deque", "list", "forward_list", "array", "stack", "queue", "priority_queue",
    "set", "multiset", "map", "multimap", "unordered_set", "unordered_multiset",
    "unordered_map", "unordered_multimap", "bitset", "tuple", "pair", "algorithm",
    "numeric", "iterator", "cmath", "cstdlib", "cstring", "ctime", "cctype", "cassert",
    "stdexcept", "string", "sstream", "iostream", "fstream", "iomanip", "ios", "iomanip",
    "cmath", "complex", "valarray", "regex", "random", "chrono", "thread", "mutex",
    "condition_variable", "atomic", "future", "filesystem",

    // C Library Functions
    "printf", "scanf", "fprintf", "fscanf", "sprintf", "sscanf", "snprintf", "vprintf",
    "vscanf", "vfprintf", "vfscanf", "vsprintf", "vsscanf", "vsnprintf", "gets", "puts",
    "fgets", "fputs", "getc", "putc", "getchar", "putchar", "feof", "ferror", "clearerr",
    "rewind", "fseek", "ftell", "fgetpos", "fsetpos", "feof", "ferror", "clearerr", "remove",
    "rename", "tmpfile", "tmpnam", "abort", "exit", "atexit", "getenv", "system", "rand",
    "srand", "malloc", "calloc", "realloc", "free", "atof", "atoi", "atol", "strtod", "strtol",
    "strtoul", "strtoll", "strtoull", "rand", "srand", "abort", "exit", "atexit", "getenv",
    "system"

    // Additional Keywords
    "int8_t", "int16_t", "int32_t", "int64_t", "uint8_t", "uint16_t", "uint32_t", "uint64_t",
    "float_t", "double_t", "size_t", "ptrdiff_t", "nullptr_t", "wchar_t", "char16_t", "char32_t",
    "constexpr", "noexcept", "override", "final", "decltype", "namespace", "inline", "virtual",
    "friend", "explicit", "mutable", "using", "extern", "static", "thread_local", "register",
    "volatile", "alignas", "alignof", "sizeof", "typeid", "dynamic_cast", "static_cast",
    "const_cast", "reinterpret_cast", "true", "false", "and", "or", "not", "not_eq", "bitand",
    "bitor", "xor", "xor_eq", "compl", "bitand", "bitor", "bitxor", "bitand_eq", "bitor_eq",
    "bitxor_eq", "comma", "concept", "requires", "main", "windows", "tchar", "TCHAR", "h"
};


string readFile(const string& filePath) 
{
    string content;
    ifstream file(filePath);
    if (file) 
    {
        content.assign((istreambuf_iterator<char>(file)), (istreambuf_iterator<char>()));
        file.close();
    }
    return content;
}

bool isKeyword(const string& word) 
{
    return cppKeywords.find(word) != cppKeywords.end();
}

void obfuscate(string& content) {
    hash<string> hasher;
    string currentWord;
    string obfuscatedContent;
    bool insideQuotes = false;
    for (char currentChar : content) {
        if (currentChar == '"') {
            insideQuotes = !insideQuotes;
            obfuscatedContent += currentChar;
            continue;
        }

        if (insideQuotes) {
            obfuscatedContent += currentChar;
            continue;
        }

        if (isalnum(currentChar)) {
            currentWord += currentChar;
        }
        else {
            if (!currentWord.empty()) {
                if (!isKeyword(currentWord)) {
                    size_t hashValue = hasher(currentWord);
                    obfuscatedContent += "ObfuscatedHash_" + to_string(hashValue);
                }
                else {
                    obfuscatedContent += currentWord;
                }
                currentWord.clear();
            }
            obfuscatedContent += currentChar;
        }
    }
    content = obfuscatedContent;
}

bool writeFile(const string& filePath, const string& content) 
{
    ofstream file(filePath);
    if (file) {
        file << content;
        file.close();
        return true;
    }
    return false;
}

int main() {
    string inputFilePath, outputFilePath;
    cout << "Enter input file path: ";
    cin >> inputFilePath;
    cout << "Enter output file path: ";
    cin >> outputFilePath;

    string fileContent = readFile(inputFilePath);
    if (fileContent.empty()) {
        cerr << "Error: Unable to read file: " << inputFilePath << endl;
        return 1;
    }

    obfuscate(fileContent);

    if (!writeFile(outputFilePath, fileContent)) {
        cerr << "Error: Unable to write to file: " << outputFilePath << endl;
        return 1;
    }

    cout << "Code obfuscated successfully and saved to: " << outputFilePath << endl;

    return 0;
}
